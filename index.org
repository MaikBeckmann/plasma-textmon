#+Title: Digitize your TextMon :D
#+Author: Maik Beckmann &lt;beckmann.maik@googlemail.com&gt;
#+Language: en
#+Style: <link rel="stylesheet" type="text/css" href="org-mode.css"/>

* COMMENT Planning
** js on the command line
js/rhino/qs_eval

*** Hello Javascript
*** Error messages
** plasmoidviwer
*** plasmoid hello world
*** Where the .. is the message?
It's burried in debug messages -__-

 : mv $(kde4-config --localprefix)/share/config/kdebugrc \
 :    $(kde4-config --localprefix)/share/config/kdebugrc_bak

Make this the content kdebugrc
#+begin_src conf
  [plasmoidviewer]
  InfoOutput=4
#+end_src
 - 2 :: stdout
 - 4 :: /dev/null

*** The error messaes suck, use js to get more insight

** Halde
*** With debug output (aka info)
 : plasmoidviewer(31094) SimpleJavaScriptApplet::reportError: "Error in contents/code/main.js on line 1.<br><br>SyntaxError: Parse error"
 : plasmoidviewer(31094) SimpleJavaScriptApplet::reportError: ("<anonymous>()@/home/maik/Projekte/kde/plasmoids/javascript/tmp/contents/code/main.js:1")
 : plasmoidviewer(31094) SimpleJavaScriptApplet::reportError: "Error in contents/code/main.js on line 1.<br><br>SyntaxError: Parse error"
 : plasmoidviewer(31094) SimpleJavaScriptApplet::reportError: ("<anonymous>()@/home/maik/Projekte/kde/plasmoids/javascript/tmp/contents/code/main.js:1")

 : plasmoidviewer(31094) SimpleJavaScriptApplet::reportError: "Error in contents/code/main.js on line 1.<br><br>SyntaxError: Parse error"
 : plasmoidviewer(31094) SimpleJavaScriptApplet::reportError: ("<anonymous>()@/home/maik/Projekte/kde/plasmoids/javascript/tmp/contents/code/main.js:1")

 : "Error in contents/code/main.js on line 1.<br><br>SyntaxError: Parse error"
 : ("<anonymous>()@/home/maik/Projekte/kde/plasmoids/javascript/tmp/contents/code/main.js:1")

 : "Error in contents/code/main.js on line 1.<br><br>SyntaxError: Parse error"


* Introduction
This guide aims to show you how to code a simple sytem minitor plasma applet in
Javascript.

* Hello Javascript
** Install a Javascript interpreter
** Not Ubuntu
*** js
This is Mozilla's command line Javascript interpreter.  It's what I'll be using
throughout this document, like
 : % js foobar.js

The package which contains this executable
  - js :: for ArchLinux, OpenSUSE and Fedora
  - spidermonkey-bin :: for Debian

It is _not_ available on *Ubuntu*.  You have to use one of the two following.

*** v8
The =v8= package contains the =d8= Javscript interpreter.  When this documention says
 : % js foobar.js
then you can use
 : % d8 foobar.js
instead.

*** rhino
This is an Java implementation.  It will take forever to startup the first time
it runs, but after that it's ok.  When this documention says
 : % js foobar.js
then you can use
 : % rhino foobar.js
instead.

Note: Only about Ubuntu I know for certain that it's =rhino= package includes
the =/usr/bin/rhino= shell script.  On Archlinux you'd have to do
 : % java -jar /usr/share/java/js.jar foobar.js

** Hello World
Open your favorite editor and create the file =foobar.js= with the content
#+begin_src js
  print("Hello World!");
#+end_src
and run it in a shell
 : % js foobar.js
 : Hello World!

* Hello Plasma
** And there was metadata
We aim to have plasma run our little world script.
#+begin_src js
  print("hello world");
#+end_src
For this we have to create a plasma package.  A package consists of its
content, our Javascript file, and meta data that describes this content and its
role.  The file tree of the simplest possible package looks like this
 : hello_world
 : ├── contents
 : │   └── main.js
 : └── metadata.desktop
The simplest possible and barely working meta data is
#+begin_src conf
  [Desktop Entry]
  Type=Service
  X-Plasma-API=javascript
  X-Plasma-MainScript=main.js
#+end_src
Now change to the directory =hello_world=, which contains the =metadata.desktop=
file, and execute
 : plasmoidviewer .
An empty default applet appears, since we haven't done anything to the user
interface yet, and the text
 : hello world
appears in the shell where we started plasmoidviewer
#+caption: Empty default applet
#+label: fig:empty_default
##+attr_html: width="150"
[[file:images/empty_default_applet.png]]

** plasmapkg and life ain't easy
To make our applet be usable for plasma we have to install it.  We'll install
it into our user directory
 : % echo $(kde4-config --localprefix)
which will be something like =/home/YOU/.kde= or =/home/YOU/.kde4=, just paste
it into the shel and see for yourself.  The follwing command does the
installation
 : % plasmapkg -i .
But it won't work.  It fails with
 : plasmapkg(24248)/libplasma Plasma::Package::installPackage: Package plugin name not specified
 : Installation of /home/maik/.../hello_world failed.
Okay, lets add a name.  The name is provided by =X-KDE-PluginInfo-Name=
#+begin_src conf
  [Desktop Entry]
  Type=Service

  X-KDE-PluginInfo-Name=HelloFoobar
  X-Plasma-API=javascript
  X-Plasma-MainScript=main.js
#+end_src
Lets try again
 : % plasmapkg -i .
 : Successfully installed /home/maik/Projekte/kde/plasmoids/javascript/textmon_tut/hello_world
Yay!  Now we want to run it.  Plasmoidviewer can to do that as well.  Instead
of giving a path to it, we give the name we've put into the meta data
 : % plasmoidviewer HelloFoobar
But it won't work, again.  You get
#+caption: Missing X-KDE-ServiceTypes
#+label: fig:missing_servicetypes
#+attr_html: width="250"
[[file:images/missing_servicetypes.png]]
#
BUMMER!  But wait, there is more fail to come.  Before I explain what is
missing, lets try to get rid if the faulty installation.  You generally can
remove plasma components with
 : % plasmapkg -r PACKAGENAME
But
 : % plasmapkg -r HelloFoobar
results in
 : Plugin HelloFoobar is not installed.
WAT?  That is clearly not correct.  It is a bug in plasmapkg that I'll report
ASAP, I promise.  I the mean time do this
 : % rm $(kde4-config --localprefix)/share/kde4/services/plasma-applet-HelloFoobar.desktop
 : % rm $(kde4-config --localprefix)/share/apps/plasma/plasmoids/HelloFoobar/ -r

What we have to add is the role this /Service/ named /HelloFoobar/ plays.  It's
a plasma applet:
#+begin_src conf
  [Desktop Entry]
  Type=Service

  X-KDE-PluginInfo-Name=HelloFoobar
  X-KDE-ServiceTypes=Plasma/Applet

  X-Plasma-API=javascript
  X-Plasma-MainScript=main.js
#+end_src
No we can not only
 : % plasmapkg -i .
 : Successfully installed /home/maik/Projekte/kde/plasmoids/javascript/textmon_tut/hello_world
but also
: % plasmoidviewer HelloFoobar
: hello world
as well as
 : % plasmapkg -r HelloFoobar
 : Successfully removed HelloFoobar
Yay :D

Since we have a package that plasmapkg can chew on without choking I suggest
you play a bit with the options it provides.  We already saw how to install
 : % plasmapkg -i /path/to/package/dir/
 : % plasmapkg -i /path/to/package.plasmoid
where we used the first version with
 : % plasmapkg -i .
We also, though unsuccessfully, used the command line to remove a package
 : % plasmapkg -r PACKAGENAME
 : % plasmapkg -r /path/to/package/dir/
The second one reads the name of the package to remove from the
=metadata.desktop= file in the directory it was given the path to.  That's why
 : % plasmapkg -r .
just reverts the things done by =plasmapkg -i=.  Well, once the bug mentioned
above is fixed :P.  Finally the plasmapkg command you'll be using most of the
time is that to upgrading an existing package
 : % plasmapkg -u /path/to/package/dir/
 : % plasmapkg -u /path/to/package.plasmoid
This actually removes the package and installs it again.  For example
 : % plasmapkg -u .
and
 : % plasmapkg -r .
 : % plasmapkg -i .
do the very same things.

** Give yourself a treat: Good error messages
Consider this code
#+begin_src js
  array = [1, 2, 3];
#+end_src
and break it
=foobar.js=
#+begin_src js
  array = [1, 2 3];
#+end_src
Put that into our main.js and see what plasma has to say
 : % plasmoidviwer .
We get this:
#+caption: Syntax Error: Parse Error.  This means: dunno!
#+label: fig:missing_servicetypes
#+attr_html: width="250"
[[file:images/syntax_error.png]]
#
Well ok, parsing a programming language is hard.  I'm sure they done as good as
anybody can ask for, right?  Lets see what the contenders have to say. Here
Mozilla's js
 : % js main.js
 : main.js:1: SyntaxError: missing ] after element list:
 : main.js:1: array = [1, 2 3];
 : main.js:1: ..............^
or Google's v8 (its command line debugger is called d8)
 :% d8 main.js
 : main.js:1: SyntaxError: Unexpected number
 : array = [1, 2 3];
 :               ^
 : SyntaxError: Unexpected number
or rhino, as well done by Mozilla
 : % rhino main.js
 : js: "main.js", line 1: missing ] after element list
 : js: array = [1, 2 3];
 : js: ...............^
Rhino is off by one dot, but still: wow!

A missing comma, brace and bracet is an frequent coding error.  QtScript will
give you the line number, that's it.  If you have no idea what the heck it's
problem is, do yourself a favor by pasting the code in question into file and
have one of the above Javascript interpreters a run at it.  They of cause won't
be able to run it, but they'll find the syntax error with a _sweet_ error
message.

* Hello?
** Getting more than one shot
Our script is run exactly once!  To get more than this single run, we have to
convince plasma to give us additional cpu cycles.  this is done by defining a
data sink and connecting it to a source.

** A sink with a slot
An object acts as the sink and a function as the slot that connects the source
to the sink
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print("ping");
    }
  };
#+end_src
The name of the sink Object can be anything
#+begin_src js
  var CatDog = {
    dataUpdated: function (name, data) {
      print("ping");
    }
  };
#+end_src
The name of the slot function however is to be =dataUpdated=.  The function
always receives two parameters.  We'll dicuss their content in a bit.

** Connecting the slot to a source
A plasma engine provides sources.  They're connected to via their
=connectSource= method.  The arguments this method takes are the name of the
source, the sink object and the desired interval length in which sink's
=dataUpdated= slot should be called.
#+begin_src js
  var engine = dataEngine("SourcesServingEngine")
  var intervalInMilliSeconds = 1000;  // one second
  engine.connectSource("SourceOfInterest", sink, intervalInMilliSeconds);
#+end_src
This code has a flaw.  The connection might fail of
 - the source doesn't exist
 - the sink object doesn't define the =dataUpdated= slot.
This flowing version doesn't really handle these situation, but at least tells
us about it.
#+begin_src js
  var engine = dataEngine("SourcesServingEngine")
  var intervalInMilliSeconds = 1000;  // one second
  if (! engine.connectSource("SourceOfInterest", sink, intervalInMilliSeconds) ) {
    print("connection attempt to SourceOfInterest in SourcesServingEngine failed D:");
  }
#+end_src

To actually find a data source and a source it provides we gonna use
 : % plasmaengineexplorer
#+caption: Plasma engine explorer
#+label: fig:plasmaengineexplorer
##+attr_html: width="605"
[[file:images/plasmaengineexplorer.png]]
#
In image \ref{fig:plasmaengineexplorer} the source /Local/ of the /time/ data
engine is expanded.  This code uses it
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print("ping");
    }
  };

  var engine = dataEngine("time");
  if ( engine.connectSource("Local", sink, 1000) ) {
    print("connection established");
  } else {
    print("connection attempt failed");
  }

  print("main.js ends here");
#+end_src
and results in
 : ping
 : connection established
 : main.js ends here
 : ping
 : ping
 : ping

As you can see, connectSource calls the dataUpdated slot.  So make sure that
it's already there.  If not
#+begin_src js
  var sink = {};

  var engine = dataEngine("time");
  if ( engine.connectSource("Local", sink, 1000) ) {
    print("connection established");
  } else {
    print("connection attempt failed");
  }

  sink.dataUpdated = function (name, data) {
    print("ping");
  }

  print("main.js ends here");
#+end_src
we'll get
 : % plasmoidviewer .
 : connection attempt failed
 : main.js ends here
 : %

** Exploring a data source
So far it is only confirmed that =dataUpdated= was called back.  Now we take a
look at the value of the parameters it is called with by the data engine.

First the =name=.  This code for the sink section
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print(name);
    }
  };
#+end_src
results in
 : Local
 : connection established
 : main.js ends here
 : Local
 : Local
 : ...
This is the same name we used with =connectSource=.  This becomes important
when we subscribe to more than one data source.
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print(name);
    }
  };

  var engine = dataEngine("time");
  if ( engine.connectSource("Local", sink, 1000) ) {
    print("connection to 'Local' in 'time' established");
  } else {
    print("connection attempt to 'Local' in 'time' failed");
  }
  //
  if ( engine.connectSource("Europe/London", sink, 1000) ) {
    print("connection to 'Europe/London' in 'time' established");
  } else {
    print("connection attempt to 'Europe/London' in 'time' failed");
  }

  print("main.js ends here");
#+end_src
 :  % plasmoidviewer .
 : Local
 : connection to 'Local' in 'time' established
 : Europe/London
 : connection to 'Europe/London' in 'time' established
 : main.js ends here
 : Local
 : Europe/London
 : Local
 : Europe/Londo

Now the =data=.  We're using the version that only connects to =Local= in
=time= with this slot definition
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print("===== data =====");
      for(var k in data) {
        print("key : " + k);
        print("data[key] : " + data[k]);
        print("typeof data[key] : " + typeof data[k]);
        print("----");
      }
    }
  };
#+end_src
It results in
 : ===== data =====
 : key : Timezone Continent
 : typeof data[key] : string
 : data[key] : Europe
 : ----
 : key : Offset
 : typeof data[key] : number
 : data[key] : 3600
 : ----
 : key : DateTime
 : typeof data[key] : object
 : data[key] : Sun Feb 12 2012 09:46:52 GMT+0100 (CET)
 : ----
 : key : Timezone
 : typeof data[key] : string
 : data[key] : Europe/Berlin
 : ----
 : key : Time
 : typeof data[key] : object
 : data[key] : 09:46:52
 : ----
 : key : Date
 : typeof data[key] : object
 : data[key] : Sun Feb 12 2012 00:00:00 GMT+0100 (CET)
 : ----
 : key : Timezone City
 : typeof data[key] : string
 : data[key] : Berlin
The =Offset= looks off, doesn't it?.  That's because its unit is seconds.  My
time zone has an offset of
 :           3600 s * 1 min
 : 3600 s =  -------------- = 60 min
 :                    60 s
 :
 :           60 min * 1 h
 : 60 min =  -------------- = 1 h .
 :                 60 min

If you compare this data with what is shown in \ref{fig:plasmaengineexplorer},
then you'll notice it being exactly the same, except for the actual point in
time.  For Qt data types that don't have an builtin equivalent in Javascript we
get an object.
 - [[http://doc.qt.nokia.com/4.7-snapshot/scripting.html#conversion-between-qtscript-and-c-types][Conversion between QtScript and C++ types]]
Lets have a peek into what one of these converted Qt types has to offer
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print("==== data =====");
      var dateTime = data["DateTime"]
      print('<properties of data["DateTime"]');
      for(var k in dateTime) {
        print("key : " + k);
        print('typeof dateTime[key] : ' + typeof dateTime[k]);
        print('dateTime[key] : ' + dateTime[k]);
      }
      print('</properties of data["DateTime"]');
    }
  };
#+end_src
 : ==== data =====
 : <properties of data["DateTime"]
 : </properties of data["DateTime"]
Nothing?  That is correct.  This shell around an C++ object only hands out you
a string representation of its value to Javascript.  Though they are not
showing up with the code above, these objects have the following methods
 - =toString()=
 - =toLocaleString()=
 - =valueOf()=
 - =hasOwnProperty(V)=
 - =isPrototypeOf(V)=
 - =propertyIsEnumerable(V)=
The Qt docs just mention their existence
 - http://doc.qt.nokia.com/4.7-snapshot/ecmascript.html
For real information head over to Mozilla
 - https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object
However, you probably only ever use =toString()=.
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print("==== data =====");
      var dateTime = data["DateTime"]
      print("typeof dateTime : " + typeof dateTime);
      print("typeof dateTime.toString : " + typeof dateTime.toString);
      print("typeof dateTime.toString() : " + typeof dateTime.toString());
      print("dateTime.toString() : " + dateTime.toString());
    }
  };
#+end_src
 : ==== data =====
 : typeof dateTime : object
 : typeof dateTime.toString : function
 : typeof dateTime.toString() : string
 : dateTime.toString() : Sun Feb 12 2012 11:45:39 GMT+0100 (CET)

* The /systemmonitor/ date engine
** CPU load
#+caption: systemmonitor : the system's total cpu load
#+label: fig:cpu_total_load
##+attr_html: width="605"
[[file:images/cpu_total_load.png]]

#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print("==== data =====");
      for(var k in data) {
        print("key : " + k);
        print('data[key] : ' + data[k]);
        print("---")
      }
    }
  };

  var engine = dataEngine("systemmonitor");
  if ( engine.connectSource("cpu/system/TotalLoad", sink, 1000) ) {
    print("connection established");
  } else {
    print("connection attempt failed");
  }

  print("main.js ends here");
#+end_src
 : ==== data =====
 : key : type
 : data[key] : float
 : ---
 : ==== data =====
 : key : units
 : data[key] : %
 : ---
 : key : type
 : data[key] : float
 : ---
 : key : value
 : data[key] : 1.503759
 : ---
 : key : min
 : data[key] : 0
 : ---
 : key : name
 : data[key] : CPU Total Load
 : ---
 : key : max
 : data[key] : 100

#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print(data["value"] + data["units"]);
    }
  };
#+end_src
 : connection established
 : main.js ends here
 : NaN
 : 4.834606%
 : 0.502513%
 : 1.012658%

#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      // No data aviable. God knows why
      if (!data["value"]) {
        return;
      }

      print(data["value"] + data["units"]);
    }
  };
#+end_src
 : connection established
 : main.js ends here
 : 4.822335%
 : 0.751880%
 : 0.501253%


- http://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      // No data aviable. God knows why
      if (!data["value"]) {
        return;
      }

      print(parseInt(data["value"], 10) + data["units"]);
    }
  };
#+end_src
 : connection established
 : main.js ends here
 : 5%
 : 2%
 : 0%

** Application memory
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print(data["value"] + data["units"]);
    }
  };

  var engine = dataEngine("systemmonitor");
  if ( engine.connectSource("mem/physical/application", sink, 1000) ) {
    print("connection established");
  } else {
    print("connection attempt failed");
  }

  print("main.js ends here");
#+end_src
 : connection established
 : main.js ends here
 : NaN
 : 2077064KB
 : 2079192KB
 : 2079544KB

#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      if (!data["value"]) { return; }
      print(parseInt(data["value"] / 1024, 10) + "MB");
    }
  };
#+end_src
 : connection established
 : main.js ends here
 : 1934MB
 : 1932MB
 : 1932MB
** Wlan
*** Down rate
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print(data["value"] + data["units"]);
    }
  };

  var engine = dataEngine("systemmonitor");
  if ( engine.connectSource("network/interfaces/wlan0/receiver/data", sink, 1000) ) {
    print("connection established");
  } else {
    print("connection attempt failed");
  }

  print("main.js ends here");
#+end_src
connection established
main.js ends here
NaN
89KB/s
103KB/s
105KB/s

#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      if (!data["value"]) { return; }
      print(data["value"] + data["units"]);
    }
  };
#+end_src
 : connection established
 : main.js ends here
 : 124KB/s
 : 97KB/s
 : 131KB/s

*** Up rate
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      if (!data["value"]) { return; }
      print(data["value"] + data["units"]);
    }
  };

  var engine = dataEngine("systemmonitor");
  if ( engine.connectSource("network/interfaces/wlan0/transmitter/data", sink, 1000) ) {
    print("connection established");
  } else {
    print("connection attempt failed");
  }

  print("main.js ends here");

#+end_src
 : connection established
 : main.js ends here
 : 5KB/s
 : 6KB/s
 : 6KB/s

*** Joined data
#+begin_src js
  var sink = (function () {
    var obj = {}

    obj.sourceUp = "network/interfaces/wlan0/transmitter/data";
    obj.sourceDown = "network/interfaces/wlan0/receiver/data";
    obj.cache = {
      up: {value: "----", units: "KB/s"},
      down: {value: "----", units: "KB/s"}
    };

    obj.dataUpdated = function (name, data) {
      if (!data["value"]) { return; }

      // TODO: up and down tauchen
      if (name == this.sourceUp) {
        this.cache.up = data;
      } else if (name == this.sourceDown) {
        this.cache.down = data;
      }

      var msg = "down: " + this.cache.down["value"] + this.cache.down["units"];
      msg += " ";
      msg += "up: " + this.cache.up["value"] + this.cache.up["units"];
      print(msg);
    }

    return obj;
  })();


  var engine = dataEngine("systemmonitor");

  if ( engine.connectSource(sink.sourceDown, sink, 1000) ) {
    print("connection to '" +  sink.sourceDown + "' established");
  } else {
    print("connection attempt to '" + sink.sourceDown + "' failed");
  }

  if ( engine.connectSource(sink.sourceUp, sink, 1000) ) {
    print("connection to '" +  sink.sourceUp + "' established");
  } else {
    print("connection attempt to '" + sink.sourceUp + "' failed");
  }


  print("main.js ends here");
#+end_src
 : connection to 'network/interfaces/wlan0/receiver/data' established
 : connection to 'network/interfaces/wlan0/transmitter/data' established
 : main.js ends here
 : down: ----KB/s up: 5KB/s
 : down: 105KB/s up: 5KB/s
 : down: 105KB/s up: 5KB/s
 : down: 91KB/s up: 5KB/s
 : down: 91KB/s up: 6KB/s
 : down: 147KB/s up: 6KB/s

** Harddisk
*** Read rate
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      print(data["value"] + data["units"]);
    }
  };

  var engine = dataEngine("systemmonitor");
  if ( engine.connectSource("disk/sda_(8:0)/Rate/rblk", sink, 1000) ) {
    print("connection established");
  } else {
    print("connection attempt failed");
  }

  print("main.js ends here");
#+end_src
 : connection established
 : main.js ends here
 : NaN
 : 0.000000KB/s
 : 0.000000KB/s
 : 0.000000KB/s

#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      // No data aviable. God knows why
      if (!data["value"]) {
        return;
      }

      print(parseInt(data["value"], 10) + data["units"]);
    }
  };
#+end_src
 : connection established
 : main.js ends here
 : 0KB/s
 : 0KB/s
 : 0KB/s

*** Write rate
#+begin_src js
  var sink = {
    dataUpdated: function (name, data) {
      // No data aviable. God knows why
      if (!data["value"]) {
        return;
      }

      print(parseInt(data["value"], 10) + data["units"]);
    }
  };

  var engine = dataEngine("systemmonitor");
  if ( engine.connectSource("disk/sda_(8:0)/Rate/wblk", sink, 1000) ) {
    print("connection established");
  } else {
    print("connection attempt failed");
  }

  print("main.js ends here");
#+end_src
 : connection established
 : main.js ends here
 : 0KB/s
 : 0KB/s
 : 0KB/s
*** Joined data
#+begin_src js
  var sink = (function () {
    var obj = {}

    obj.sourceRead = "disk/sda_(8:0)/Rate/wblk";
    obj.sourceWrite = "disk/sda_(8:0)/Rate/rblk";
    obj.cache = {
      read: {value: "----", units: "KB/s"},
      write: {value: "----", units: "KB/s"}
    };

    obj.dataUpdated = function (name, data) {
      if (!data["value"]) { return; }

      if (name == this.sourceRead) {
        this.cache.read = data;
        this.cache.read["value"] = parseInt(data["value"], 10);
      } else if (name == this.sourceWrite) {
        this.cache.write = data;
        this.cache.write["value"] = parseInt(data["value"], 10);
      }

      var msg = "read: " + this.cache.read["value"]
                         + this.cache.read["units"];
      msg += " ";
      msg += "write: " + this.cache.write["value"]
                       + this.cache.write["units"];
      print(msg);
    }

    return obj;
  })();


  var engine = dataEngine("systemmonitor");

  if ( engine.connectSource(sink.sourceRead, sink, 1000) ) {
    print("connection to '" +  sink.sourceRead + "' established");
  } else {
    print("connection attempt to '" + sink.sourceRead + "' failed");
  }

  if ( engine.connectSource(sink.sourceWrite, sink, 1000) ) {
    print("connection to '" +  sink.sourceWrite + "' established");
  } else {
    print("connection attempt to '" + sink.sourceWrite + "' failed");
  }


  print("main.js ends here");
#+end_src
 : connection to 'disk/sda_(8:0)/Rate/wblk' established
 : connection to 'disk/sda_(8:0)/Rate/rblk' established
 : main.js ends here
 : read: ----KB/s write: 0KB/s
 : read: 0KB/s write: 0KB/s
 : read: 0KB/s write: 0KB/s


* UI
The only two UI widget we'll use are a [[http://techbase.kde.org/Development/Tutorials/Plasma/JavaScript/API-UIElements#Label][Labels]], a [[http://techbase.kde.org/Development/Tutorials/Plasma/JavaScript/API-UIElements#LinearLayout][Layout]] to arrange them and the
[[http://techbase.kde.org/Development/Tutorials/Plasma/JavaScript/API-PlasmoidObject][plasmoid]] itself.

** Hello plasmoid
The applet itself is represented by a global object named =plasmoid=.  We gonna
take a look at what properties it has to offer
#+begin_src js
  for(var k in plasmoid) {
    print(k);
  }
#+end_src
 : objectName
 : aspectRatioMode
 : formFactor
 : location
 : currentActivity
 : shouldConserveResources
 : activeConfig
 : busy
 : backgroundHints
 : immutable
 : userConfiguring
 : apiVersion
 : status
 : rect
 : size
 : associatedApplication
 : layout
 : sender
 : destroyed(QObject*)
 : destroyed()
 : releaseVisualFocus()
 : configNeedsSaving()
 : formFactorChanged()
 : locationChanged()
 : contextChanged()
 : immutableChanged()
 : statusChanged()
 : gc()
 : formFactor()
 : aspectRatioMode()
 : setAspectRatioMode(AspectRatioMode)
 : setFailedToLaunch(bool,QString)
 : setFailedToLaunch(bool)
 : isBusy()
 : setBusy(bool)
 : backgroundHints()
 : setBackgroundHints(BackgroundHints)
 : setConfigurationRequired(bool,QString)
 : setConfigurationRequired(bool)
 : size()
 : rect()
 : setActionSeparator(QString)
 : setAction(QString,QString,QString,QString)
 : setAction(QString,QString,QString)
 : setAction(QString,QString)
 : removeAction(QString)
 : action(QString)
 : resize(qreal,qreal)
 : setMinimumSize(qreal,qreal)
 : setPreferredSize(qreal,qreal)
 : activeConfig()
 : setActiveConfig(QString)
 : readConfig(QString)
 : writeConfig(QString,QVariant)
 : file(QString)
 : file(QString,QString)
 : include(QString)
 : debug(QString)
 : findChild(QString)
 : extender()
 : downloadedFiles()
 : update(QRectF)
 : update()
 : listAddons
 : loadAddon
 : addEventListener
 : removeEventListener
 : hasExtension
 : __qt_scope__
From the number of properties alone you can tell that it must be important :P.

And it is.  The =P= in this graph
 :             P
 :            / \
 :           /   \
 :          /     \
 :         /       \
 :        O         O
 :       / \       /|\
 :      /   \     / | \
 :     O     O   O  O  O
represents =plasmoid=.  It is the root object of our applet.  All other elemets
in it are represented by an =O=.  If the applet is destroyed (by closing the
window of shutting plasma down) it starts a cleanup cascade.  It tells its
immediate children to kill their children and so on.

Besizes that role it has some methods that control the outer dimensions and
orientation of the applet.  For example
#+begin_src js
  plasmoid.resize(300, 30);
#+end_src
#+caption: Resize
[[file:images/resize.png]]
#
The object graph for this applet is rather simple
 :             P
We gonna change that now.

** Hello label
This code
#+begin_src js
  l = new Label(plasmoid) // adds it as child of plasmoid
  l.text = "Hello World";
#+end_src
puts a label =l= object into the graph
 :             P
 :             |
 :             |
 :             l

The result
#+caption: Hello label
[[file:images/hello_label.png]]
#
This looks broken, doesn't it?  A label on it's own doesn't what to do with
itself.

** Hello layout
The label needs some guidance, which will be delivered by an layout =L=
 :             P
 :             |
 :             |
 :             L
 :             |
 :             |
 :             l
#+begin_src js
  layout = new LinearLayout(plasmoid); // add it as child of plasmoid

  l = new Label()
  l.text = "Hello World";
  layout.addItem(l); // inserts it as cild of layout
#+end_src
The result is
#+caption: Hello layout
[[file:images/hello_layout.png]]
#
That looks a lot better.  However, I cheated.  You'll see prabably this:
#+caption: Hello layout, err
[[file:images/hello_layout_err.png]]
#
That is a lovely little bug that only occurs when the applet is run via
/plasmoidviewer/.  You can fix it buy resizing the plasmoid a tiny bit.
Actually, we can do that in the script itself
#+begin_src js
  layout = new LinearLayout(plasmoid); // add it as child of plasmoid

  l = new Label()
  l.text = "Hello World";
  layout.addItem(l); // inserts it as cild of layout

  // ugly little hack to work around layout issue when using plasmoidviewer
  plasmoid.resize(201, 200)
  plasmoid.resize(200, 200)
#+end_src
I'll use that trick from now on, but won't actually include it in the code
listings.

** More labels!
This code
#+begin_src js
layout = new LinearLayout(plasmoid); // add it as child of plasmoid

labels = [];
for(var i = 0; i < 4; i++) {
  l = new Label()
  l.text = "l" + i;
  layout.addItem(l); // inserts it as cild of layout

  labels.push(l); // for later usage
}
#+end_src
builds this object graph
 :             P
 :             |
 :             L
 :             |
 :      o----o-----o---o
 :      |    |     |   |
 :     l0   l1    l2  l3
The resulting applet is
#+caption: More labels
[[file:images/more_labels.png]]

TODO:
 - dummy layout with fake cpu, mem, wlan and sda values
 - the real deal

Idea: Maybe this is too much.  It might be a good idea to create seperate applets for
 - cpu
 - mem
 - mem and cpu
 - wlan up
 - wlan down
 - wlan up and down
 - sda read
 - sda write
 - sda read and write
